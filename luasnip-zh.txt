*zh-luasnip*

# LuaSnip

LuaSnip 是一个完全用 lua 编写的代码片段引擎。
它具有以下强大功能：根据用户输入插入文本 (`luasnip-function-node`) 或节点 (`luasnip-dynamic-node`),
解析 LSP 语法和切换节点 (`luasnip-choice-node`) 等。关于键位映射和安装等基本设置，请查看 README 文件。

此帮助文档中所有代码片段假定：

```lua
local ls = require("luasnip")
local s = ls.snippet
local sn = ls.snippet_node
local isn = ls.indent_snippet_node
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node
local c = ls.choice_node
local d = ls.dynamic_node
local r = ls.restore_node
local events = require("luasnip.util.events")
local ai = require("luasnip.nodes.absolute_indexer")
local extras = require("luasnip.extras")
local l = extras.lambda
local rep = extras.rep
local p = extras.partial
local m = extras.match
local n = extras.nonempty
local dl = extras.dynamic_lambda
local fmt = require("luasnip.extras.fmt").fmt
local fmta = require("luasnip.extras.fmt").fmta
local conds = require("luasnip.extras.expand_conditions")
local postfix = require("luasnip.extras.postfix").postfix
local types = require("luasnip.util.types")
local parse = require("luasnip.util.parser").parse_snippet
local ms = ls.multi_snippet
local k = require("luasnip.nodes.key_indexer").new_key
```

正如 [Loaders-Lua](#lua-zh-luasnip-loaders-lua) 一节所提：

>默认使用来自 [luasnip.config.snip_env](https://github.com/L3MON4D3/LuaSnip/blob/master/lua/luasnip/config.lua#L22-L48) 的名称,但也可以在 `setup` 中设置 `snip_env` 自定义。

此外注意,虽然本文档假定 `ls` 定义为 `require("luasnip")` ,但在默认设置的变量中并未提供。

---

## Basics *zh-luasnip-basics*

在 LuaSnip 中，代码片段由 `nodes` 组成。节点包括：

- `textNode`：静态文本。
- `insertNode`：可编辑的文本。
- `functionNode`：可从其他节点的内容生成的文本。
- 其他节点
  - `choiceNode`：在两个节点（或更多节点）之间进行选择。
  - `restoreNode`：存储和恢复输入到节点。
- `dynamicNode`：基于输入生成的节点。

创建代码片段通常使用 `s(trigger:string, nodes:table)` 形式的函数。
在 [Snippets](#snippets-zh-luasnip-snippets) 一节有更详细解释，大意是它会创建一个代码段，包含节点中指定的各个节点。
当调用 `ls.expend` 时，如果光标前的文本与 `trigger` 匹配，这个代码段会插入到缓冲区。

---

### Jump-Index *zh-luasnip-basics-jump-index*

所有可以跳转的节点 (`insertNode`,`choiceNode`,`dynamicNode`,`restoreNode`,`snippetNode`)，
都需要一个跳转索引（jump-index），让 LuaSnip 知道这些节点按什么顺序访问（跳转）。

```lua
s("trig", {
    i(1), t"text", i(2), t"text again", i(3)
})
```

这些索引不会像 TextMate-snippets(`"$1 ${2: $3 $4}"`) 中那样贯穿整个 snippet ，而是在每个嵌套的 snippetNode 中会以1重新开始：

```lua
s("trig", {
    i(1), t" ",
    sn(2, {
        t" ", i(1),
        t" ", i(2)
    })
})
```

大致等同于给出的 TextMate 代码段。

---

## Adding Snippets *zh-luasnip-basics-adding-snippets*

某个文件类型的代码段必须通过 `ls.add_snippets(filetype,snippets)` 添加到 LuaSnip。
所有文件类型可用的代码段需要添加到特殊的文件类型 `all` 里。

```lua
ls.add_snippets("all", {
 s("ternary", {
  -- equivalent to "${1:cond} ? ${2:then} : ${3:else}"
  i(1, "cond"), t(" ? "), i(2, "then"), t(" : "), i(3, "else")
 })
})
```

可以使用 `ls.filetype_extend` 使一个文件类型的代码段到另一个文件类型使用，
更多信息见 [API](api-luasnip-api) 一节。

---

### Snippet Insertion *zh-luasnip-basics-snippet-insertion*

当一个新 snippet 展开时，它可以以各种方式连接到缓冲区中已经展开的 snippet。
首先，LuaSnip 区分 root-snippets 和 child-snippets。子代码段嵌套在其他代码段中，
所以当你跳转遍历一个代码段时，也可能会一并遍历它内部展开的子代码段，看起来就像子代码段包含父代码段的更多节点一样。

根代码段的特点，当然就是它们不是子代码段

当展开一个新代码段，如果它在某个代码段区域内被展开，那么会变为这个代码段的子节点；
如果不在任何代码段内展开，那么它是一个根代码段。

如果代码段在另一个代码段内部，那么确定它具体处于哪个节点中，然后将代码段嵌套进那个节点。

- 如果那个节点是可交互的（例如插入节点），当节点被访问时，
只要配置项 `link_chlildren` 启用，新代码段也会被遍历。
如果没有启用，只可以从代码段跳到节点，但不能从节点跳到代码段。
- 如果那个节点不可交互，代码段会会连接到当前活跃节点，一旦离开节点，不能再次跳回。
这是尽可能地为了避免在缓冲区内大范围跳转。
从代码段跳回节点时，仍然可能发生一次较大的跳转，但这似乎很难避免。
因此，在设计代码段时，其他展开的代码段区域在 `insertNode` 里。

如果一个代码段不是子代码段，而是根代码段。那么可以在`setup` 里启用 `link_root`,将它们和旁边的其他代码段连接。
因为，默认只有一个根代码段被记住，如果启用 `link_root`，也应该设置 `keep_root`。
这两个选项是分开的，因为，即使根没有被连接，仍然可以通过 `ls.active_node()` 跳转。
这种配置（记住根，但不跳到）对使用类似 super-tab 映射很有用，仍然可以进入前一个代码段。
因为，如果根被连接，会有大量跳转， `<Tab>` 会几乎无法正常工作。
所以 `link_root` 要被禁用。

---

## Node *zh-luasnip-node*

每个节点都接受一个可选的参数列表作为它的最后一个参数。
有一些通用的选项（在这里列出），也有一些仅适用于某些节点，
（比如 `user_args` 只在 function/dynamicNode中生效）。
如果接受的选项不是所有节点通用时会说明。

通用选项：

- `node_ext_opts` 和 `merge_node_ext_opts`  
控制节点的 `ext_opts`（一般是高亮）。详情见 [ext_opts](#ext_opts-zh-luasnip-ext_opts)。
- `key`  
可以引用节点。对 [Key Indexer](#key-indexer-zh-luasnip-key-indexer) 或在运行时查找节点（见 [Snippets-API](#api-zh-luasnip-snippets-api)）有用，例如在 `dynamicNode` 里。
这个 key 在 snippet 的整个生命周期内不需要是唯一的，但在任意时刻，一个代码段不能有重复 key。
这意味着，可以从 `dynamicNode` 返回带 key 的节点。
因为，即使它们被生成多次，只要不在同一时刻，就不会有冲突。
- `node_callbacks`：为节点定义 events-callbacks（见 [event](#events-zh-luasnip-events)）。  
接受一个表，将事件（例如 `events.enter`）映射到 callback（本质上和转递给 `s` 的 `callbacks` 一样）。
只是没有从跳转索引到 callbacks 表的映射。

---

### API *zh-luasnip-node-api*

- `get_jump_index()`:  
返回节点的跳跃索引。如果节点没有跳跃索引，返回空值。
- `get_buf_position(opts) -> {from_position, to_position}`  
决定这个节点占据缓冲区的范围。`from` 和 `to _position` 是行列坐标,
使用`0,0` 索引（起始行为第0行，起始列为第0列），并且包含结束位置范围。
（见 `:h api-indexing`，这里使用 extmarks 索引）。
  - `opts`:`table|nill`  
    - `raw`:`bool`，默认 `true`。  
    用于切换字节列（`raw=true`）和可视列（`raw=false`）。
    当一行包含 UTF-8 的多字节组成的字符时，会有不同。

---

## Snippets *zh-luasnip-snippets*

定义代码片段的最直接方式是 `s`：

```lua
s({trig="trigger"}, {})
```

（这段代码除了是一个最小的例子外，毫无用处。）

`s(context, nodes, opts)` -> snippet

- `context`:table or a string  
传入字符串等价传入：

```lua
{
    trig = context
}
````

可用值如下：

  - `trig`:string  
  代码段触发字符。当调用 `ls.expand()` 时，如果光标前（即左边）的文本与 trig 匹配，此代码段会展开。
  默认需完全匹配，可以通过 `trigEngine` 修改。
  - `name`：string  
  用于例如 `nvim-compe` 识别代码段。
  - `desc` 或 `decr`：string  
  代码段描述，\n分割或多行表。
  - `wordTrig`:boolean  
  如果为 true 只有当光标前的完整单词 (`[%w_]+`)匹配触发字符，代码段才会展开。默认为 true。
  - `regTrig`:boolean  
  是否以 lua 模式解释代码段。默认 false。  
  建议设置 `trigEngine` 为 `pattern`，这样更灵活，也更符合其他设置。
  - `trigEngine`:function|string  
  决定触发词如何解析，以及什么情况下它算匹配光标前的文本。
  此行为可以通过传入一个函数完全自定义，但是预定义的函数，通过传入标识符使用，
在大多数情况下完全够用。

    - `plain`  
    默认行为，触发字符必须与文本完全匹配。
    - `pattern`  
    触发词以 lua 模式解析，如果 `trig .. "$""` 能匹配到光标所在行到光标为止的文本就可以。  
    捕获组可以通过 `snippet.captures` 使用。
    - "ecma": the trigger is interpreted as an ECMAscript-regex, and is a match if trig .. "$" matches the line up to the cursor. Capture-groups will be accessible as snippet.captures.
This trigEngine requires jsregexp (see LSP-snippets-transformations) to be installed, if it is not, this engine will behave like "plain".
    - "vim": the trigger is interpreted as a vim-regex, and is a match if trig .. "$" matches the line up to the cursor. As with the other regex/pattern-engines, captures will be available as snippet.captures, but there is one caveat: the matching is done using matchlist, so for now empty-string submatches will be interpreted as unmatched, and the corresponding snippet.capture[i] will be nil (this will most likely change, don't rely on this behavior).

除了这些预定义的引擎之外，也可以创建新的引擎：与其传递一个字符串，不如传递一个函数，该函数需要满足
`trigEngine(trigger, opts) -> (matcher(line_to_cursor, trigger) -> whole_match, captures)` 的形式。
（这个函数会接收 `trig` 和 `trigEngineOpts`，例如，可以在这里预编译一个正则表达式，
然后返回一个新的函数。这个返回的函数负责判断当前光标位置
（用光标之前的整行文本来表示）是否匹配触发字符（触发字符会再次传入，这样一来，
那些不需要对触发字符做任何特定处理（比如编译）的引擎就可以直接返回一个固定的匹配器），
以及确定捕获组（capture groups）。）
例如，lua-engine 就可以这样实现：

```lua
local function matcher(line_to_cursor, trigger)
    -- look for match which ends at the cursor.
    -- put all results into a list, there might be many capture-groups.
    local find_res = { line_to_cursor:find(trigger .. "$") }

    if #find_res > 0 then
        -- if there is a match, determine matching string, and the
        -- capture-groups.
        local captures = {}
        -- find_res[1] is `from`, find_res[2] is `to` (which we already know
        -- anyway).
        local from = find_res[1]
        local match = line_to_cursor:sub(from, #line_to_cursor)
        -- collect capture-groups.
        for i = 3, #find_res do
            captures[i - 2] = find_res[i]
        end
        return match, captures
    else
        return nil
    end
end

local function engine(trigger)
    -- don't do any special work here, can't precompile lua-pattern.
    return matcher
end
```

预定义的引擎在 [trig_engines.lua](https://github.com/L3MON4D3/LuaSnip/blob/master/lua/luasnip/nodes/util/trig_engines.lua)，阅读它获取示例。

  - `hidden`:boolean  
  在补全引擎里隐藏。如果设置为 true，当查询代码片段时，该代码片段不显示。
  - `priority`:positive number  
  代码段优先级，默认1000。高优先级代码段会在那些低的之前匹配触发词。
  多个代码段可以在 `add_snippets` 里设置优先级。
  - `snippetType`:string  
  `snippet` 或 `autosnippet`，决定代码段通过 `ls.expand()` 手动触发，
  还是自动触发（不要忘记设置 `ls.config.setup({enable_autosnippets = true})`，如果你使用此功能）。
如果没有设置此选项，代码段类型则取决于代码段是如何添加
  - `resolveExpandParams`:`fn(snippet, line_to_cursor, matched_trigger, captures) -> table|nil`
  - `condition`:`fn(line_to_cursor, matched_trigger, captures) -> bool`
    - `line_to_cursor`:`string`  
    光标之前的整行字符串
    - `matched_trigger`:`string`，完整匹配触发字符（从 line_to_cursor 中获取，但这里已经提供了 :D）
    captures: 如果触发器是一个模式（pattern），这个列表包含捕获组。同样也可以从 line_to_cursor 计算得到，但我们已经处理好了。

此函数可以阻止通过 `ls.expand()` 手动展开代码片段。  
返回 true 表示允许展开，返回 false 表示阻止展开。

  - `show_condition`:`f(line_to_cursor) -> bool`

  这个函数通常由补全引擎（completion engines）调用，用来判断该 snippet 是否应该出现在当前的补全候选列表里。  
  默认是一个返回 true 的函数，也就是默认 snippet 总是可见。  
  这与 `condition` 不同，因为 `condition` 会在代码段展开时进行评估
  （因此可以访问匹配到的触发字符和捕获内容），而 `show_condition` 在扫描可用片段候选项时由补全引擎评估。
  `filetype`:`string`  
  代码段的文件类型。这会覆盖通过` add_snippet` 添加片段时指定的文件类型
- `nodes`:单个节点或节点列表。节点组成代码段。
- `opts`：一个包含以下有效键的表
  - `callbacks`：包含进入/离开节点时调用的函数。  
  例如，在进入一个代码段的第二个节点时打印文本，`callbacks` 应设置如下：  
  ```lua
  {
    -- position of the node, not the jump-index!!
    -- s("trig", {t"first node", t"second node", i(1, "third node")}).
    [2] = {
    [events.enter] = function(node, _event_args) print("2!") end
  }
  }
  ```

  为代码段自己的事件注册一个回调函数，可以使用键 `[-1]`。更多事件信息在 [events](#events-zh-luasnip-events)
  - `child_ext_opts`,`merge_child_ext_opts`：

---

### Data *zh-luasnip-snippets-data*

Snippets 在启动时包含一些有趣的表

- `snippet.env`：包含在 LSP-protocol 中使用的变量，例如：`TM_CURRENT_LINE` 或 `TM_FILENAME`。这里也可以添加自定义变量，请查看 [Variables-Environment Namespaces](#environment-namespaces-zh-luasnip-variables-environment-namespaces)
- `snippet.captures`：如果代码段由模式 (`regTrig`) 触发，并且该模式包含捕获组，那么它们可以在这里被获取。
- `snippet.trigger`：触发该片段的字符串。同样，仅在该片段是通过 `regTrig` 触发时才有意义，用于获取完整匹配。

这些变量/表主要在 `dynamicNode/functionNode` 中使用。在这里,代码段可以立刻通过父节点 (`parent.snippet`)
访问，并且该片段会被传入函数。（大多数情况下，`parent == parent.snippet`，
但是动态节点的父节点不一定最外层的代码段，它也可能是一个 `snippetNode`）。

---

### API *zh-luasnip-snippets-api*

- `invalidate()`：
- `get_keyed_node(key)`：返回与指定 `key` 关联的当前可见节点。

---

## TextNode *zh-luasnip-textnode*

最简单的节点类型；只是文本。

```lua
s("trigger", { t("Wow! Text!") })
```

此片断将展开为：

```
Wow! Text!⎵
```

其中，⎵ 是光标。

定义多行文本可以通过传递一个“多行表”而不是字符串。

```lua
s("trigger", {
    t({"line!", "Another line."})
})
```

- `t(text, node_ext_opts)`
  - `text`:`string` or `string[]`
  - `node_opts`:`table`，见 [Node](#Node-zh-luasnip-node)
---

## InsertNode *zh-luasnip-insertnode*

这种节点包含可编辑的文本，并且可以跳进和跳出（例如传统的占位符，像 textmate-snippets 中的 $1）。

该功能最好通过一个示例进行演示：

```lua
s("trigger", {
    t({"展开后，光标位于此 ->"}), i(1),
    t({"", "二行文本，一次跳转后，光标位于此 ->"}), i(2),
    t({"", "再次跳转后，代码段在这里退出 ->"}), i(0),
})
```

Insert Node 会按照 1,2,3,...,n,0 的顺序跳转。（跳转点0必须属于一个 `insertNode`!）
InsertNode 的跳转顺序如下：

1. 展开后 ，光标位于 InstertNode 1
2. 跳跃后，将位于 InsertNode 2
3. 再次跳跃后，将位于 InsertNode 0

如果在片段中未找到第0个 InsertNode，则会在所有其他节点之后自动插入一个。

跳转的顺序不必遵循节点的文本顺序：

```lua
s("trigger", {
    t({"After jumping forward once, cursor is here ->"}), i(2),
    t({"", "After expanding, the cursor is here ->"}), i(1),
    t({"", "After jumping once more, the snippet is exited there ->"}), i(0),
})
```

上述片段的行为如下所示：

1. 展开后，光标位于 InsertNode 1
2. 跳跃后，将位于 InsertNode 2
3. 再次跳跃后，将位于 InsertNode 0

一个重要的细节是跳转索引会在嵌套的代码段中从1重新开始。（因为 LuaSnip 与其他代码片段引擎不同）

```lua
s("trigger", {
    i(1, "First jump"),
    t(" :: "),
    sn(2, {
        i(1, "Second jump"),
        t" : ",
        i(2, "Third jump")
    })
})
```

与 TextMate 语法相反，在 TextMate 语法中，跳转点是全局的：

```
${1:First jump} :: ${2: ${3:Third jump} : ${4:Fourth jump}}
```

当然，这不是完全相同的片段，但尽可能接近。

重新开始的规则仅在 Lua 中定义片段时生效，上面的 TextMate 片段在 LuaSnip 中解析会正确展开。

`i(jump_index, text, node_opts)`

- jump_index
  - number,决定节点何时被跳转到（参见 zh-luasnip-basics-jump-index ）。
- text
  - string or string[],a single line 用于单行；a list 用于多行。
- node_opts
  - table, 参见 luasnip-node

如果跳转索引是0，替换它的 text（即用 i(0, "text") 的形式）会导致该文字不包含在 insertNode 里面

---

## FunctionNode *zh-luasnip-functionnode*

函数节点基于其他节点内容使用用户自定义函数插入文本。

```lua
local function fn(
    args,     -- 文本来自 i(2) in this example i.e. { { "456" } }
    parent,   -- 父代码段或父节点
    user_args -- user_args 来自 opts.user_args 
    )
    return '[' .. args[1][1] .. user_args .. ']'
end
    
s("trig", {
    i(1), t '<-i(1) ',
    f(fn,  -- callback (args, parent, user_args) -> string
        {2}, -- 节点索引，文本被传给 fn，即 i(2)
        { user_args = { "user_args_value" }} -- opts
    ),
    t ' i(2)->', i(2), t '<-i(2) i(0)->', i(0)
})
```

`f(fn, argnode_references, node_opts)`

- `fn`:`function(argnode_text, parent,user_args1,...,user_argsn) -> text`
  - `argnode_text`:`string [][]`，  
  当前被包含进 argnodes 内的文本，例如 ({{line1}, {line1, line2}})。代码段缩进从第一行后移除。
  - `parent`：函数节点的直接父节点。  
  它被包含在这里，因为它允许方便访问一些信息，这些信息在函数节点有用（示例见 Snippets-Data）
  许多代码段访问周围的代码段只是当做父节点。但是，如果函数节点被嵌套在 `snippetNode` 里，
  那么直接的父节点就是一个 `snippetNode`，而不是外层的代码段
  （只有外层的 snippet 才包含像 `env` 或 `captures` 这样的数据）
  - `user_args`：`opts` 选项被传递进 `user_args`。
  注意：可能有多个 `user_args`(eg.`user_args1, ..., user_argsn`)

`fn` 应该返回直接插入文本的字符串，或字符串表。第一行后的所有行添加代码段缩进。

- `argnode_references`:`node_reference[]|node_refernce|nil`.  
空值、单个或多个节点引用。如果任何一个引用节点变化，会重新计算 `fn` 函数，并且更新文本内容。
如果没有传入节点引用，函数节点只有在展开时被计算。
- `node_opts`:`table`  
见 Node。支持一个额外的键。
  - `user_args`:`any[]`，  
  这些将以 `user_args1`、`user_argsn` 传递给 `fn`。这样可以更方便的复用类似的函数，
  比如一个函数节点用不同的分界符包裹文本。

```lua
local function reused_func(_,_, user_arg1)
    return user_arg1
end

s("trig", {
    f(reused_func, {}, {
        user_args = {"text"}
    }),
    f(reused_func, {}, {
        user_args = {"different text"}
    }),
})
```

如果函数只是进行简单的文本操作，建议使用来自来自 `luasnip.extras` 的 `lambda`。

---

## Node Reference *zh-luasnip-node-reference*

节点引用用于在 LuaSnip's API 的各种地方引用其他节点。
举例，函数节点、动态节点或 lambda 里的参数节点就是节点引用。
这些引用有如下：

- `number`:节点跳转索引。  

---

## ChoiceNode *zh-luasnip-choicenode*

选择节点允许在多个节点项间选择。

```lua
 s("trig", c(1, {
 	t("Ugh boring, a text node"),
 	i(nil, "At least I can edit something now..."),
 	f(function(args) return "Still only counts as text!!" end, {})
 }))
```

`c(pos, choices, opts?): LuaSnip.ChoiceNode`

从选项列表中创建一个新的选择节点。
列表第一项是初始选择项，当选项中的任何节点激活时，可以更换选项。
所以，如果希望所有选项可访问，每个节点都需要有一个光标停留的位置。

如果选项是 snippetNode（类似`sn(nil,{...nodes...})`），那么节点必须包含 `insertNode`。
直接使用 `insertNode` 或 `textNode` 作为选项也是可以的。
`textNode` 会在文本开头添加一个跳转点。

- `pos:int`
  - 节点跳跃索引。
- `choices: (LuaSnip.Node|LuaSnip.Node[])[]`
  - 可以交互切换的节点列表。如果节点列表作为选项传入，它会自动转为 `insertNode`。
可跳转节点（一般需要跳转索引）不需要索引，当作为选项时。因为它们会继承选择节点的跳转索引。
- `opts?:LuaSnip.Opts.ChoiceNode?`额外可选参数，可用值：
  - 

---

## SnippetNode *zh-luasnip-snippetnode*

SnippetNode 会将它们的内容直接插入到包裹它们的 snippet 中。
这对 `choiceNode` 是有用的，因为它只接受一个子节点。
对于 `dynamicNode` 来说也很有用，因为动态节点中的内容是在运行时创建的，
并且会以 `snippetNode` 的形式插入。

语法类似 `snippet`，但是，snippet 需要一个指定合适展开的表，而 `snippetNode` 像 `insertNode` 那样需要一个跳转索引。

```lua
 s("trig", sn(1, {
 	t("basically just text "),
 	i(1, "And an insertNode.")
 }))
```

`sn(jump_index, nodes, node_opts)`

- `jump_index:number`，  
跳转索引。
- `nodes:nodep[]|node`，  
`snippetNode` 不接受 `i(0)`，所以内部跳转索引为1,2,...,n。
- `node_opts:table`  
除了支持所有节点通用的键（文档见 Node），也支持：
  - callback
  - child_ext_opts
  - merge_child_ext_opts

这些键在 Snippets 有进一步解释。

---

## IndentSnippetNode *zh-luasnip-indentsnippetnode*

---

## DynamicNode *zh-luasnip-dynamicnode*

与函数节点非常类似，但是返回的是 snippetNode，而不只是文本，
这使它非常强大，因为代码段的某部分可以基于用户输入变化。

`d(jump_index, function, node-references, opts)`:

- `jump_index`:`number`  
和所有可跳转节点一样，是在跳转列表中的位置。
- `function`:`fn(args, parent, old_state, user_args) -> snippetNode`  
当 argnodes 中的文本变化时，这个函数会被调用。
它应该生成并返回一些节点（被 `snippetNode` 包裹），
这些节点被插入进 `dynamicNode` 的位置上。
`args`,`parent` 和 `user_args` 在 FunctionNode 中有解释。
  - `args`：由文本组成的的表 `({"node1line1", "node1line2"}, {"node2line1"})`
来自 `dynamicNode` 所依赖的节点。
  - `parent`：`dynamicNode` 的直接父节点。
  - `old_state`：用户自定义表。  



## RestoreNode *zh-luasnip-restorenode*
## Key Indexer *zh-luasnip-key-indexer*
## Absolute Indexer *zh-luasnip-absolute-indexer*
## MultiSnippet *zh-luasnip-multisnippet*

---

## Extras *zh-luasnip-extras*

### Lambda *zh-luasnip -extras-lambda*

函数节点的简写，只能用于简单的字符串处理。

`l(lambda, argnodes)`


### Match *zh-luasnip-extras-match*
### Repeat *zh-luasnip-extras-repeat*
### Partial *zh-luasnip-extras-partial*
### Nonempty *zh-luasnip-extras-nonempty*
### Dynamic *zh-luasnip-extras-dynamic-lambda*

---

### fmt *zh-luasnip-extras-fmt*

编写代码段可能很繁琐，尤其是每隔一个节点就可能是一个 textNode，用于在两个更复杂节点间插入少量字符。

fmt 使用更易读的方式定义代码段，正如其名字所暗示，它借用 format 功能（语法接近与 python 的 str.format）。

fmt 接受 a string 和 a table of nodes 。字符串内的每一对分隔符（占位符）会被表内一个节点替换，而不在分隔符内的文本会转换为 textNode。

```lua
ls.add_snippets("all", {
  -- 重要! fmt 不返回代码段，它返回一个节点表。
  s("example1", fmt("just an {iNode1}", {
    iNode1 = i(1, "example")
  })),
  s("example2", fmt([[
  if {} then
    {}
  end
  ]], {
    -- i(1) is at nodes[1], i(2) at nodes[2].
    i(1, "not now"), i(2, "when")
  })),
  s("example3", fmt([[
  if <> then
    <>
  end
  ]], {
    -- i(1) is at nodes[1], i(2) at nodes[2].
    i(1, "not now"), i(2, "when")
  }, {
    delimiters = "<>"
  })),
})
```

这里有一个重要细节：分隔符位置在任何情况下都不会对应于节点的跳跃索引。

`fmt(format:string, nodes:table of nodes, opts:table|nil) -> table of nodes`

- format
  - string.出现的`{<somekey>}`（{}可自定义）会被`[<somekey>]`（应该是节点）的内容替换。分隔符周围的文本会转换为 textNode。
  - 转移分隔符，重复使用`{{`
  - 如果`{}`无键名，它们会自动编号，`{} ? {} : {}`变为`{1} ? {2} : {3}`，而`{} ? {3} : {}`变为`{1} ? {3} : {4}`（每个占位符的数字重新编号）
  - 如果某个键在 format 中出现多次，`[<duplicate_key>]`中的节点会在第一次使用时被插入，后续出现该键会复制该节点。
- nodes：节点表。
- opts：可选参数
  - delimiters：字符串。改变`{}` 为其他。
  - strict：警告未使用节点（默认开启）。
  - 12

还有`require("luasnip.extras.fmt").fmta`。它与 fmt 唯一不同是：fmta 使用<>作为默认分隔符。

---

### Conditions *zh-luasnip-extras-conditions*
### On The Fly-Snippets *zh-luasnip-extras-on-the-fly-snippets*
### select_choice *zh-luasnip-extras-select-choice*

可以利用 `vim.ui.select` 直接选择选项，而不是在可用选项间循环。需要调用 `require(luasnip.extras.select_choice)`，通常通过键位绑定使用。

```lua
inoremap <c-u> <cmd>lua require("luasnip.extras.select_choice")()<cr>
```

在处于选择节点时使用。`vim.ui.select` 的 `opts.kind` 提示参数会被设置为 `luasnip`。

---

### Filetype-Function *zh-luasnip-extras-filetype-functions*
### Postfix-Snippet *zh-luasnip-extras-postfix-snippet*
### Treesitter-Postfix-Snippet *zh-luasnip-extras-treesitter-postfix-snippet*
### Snippet List *zh-luasnip-extras-snippet-list*
### Snippet Location *zh-luasnip-extras-snippet-location*
## Extend Decorator *zh-luasnip-extend-decorator*
## LSP-Snippets *zh-luasnip-lsp-snippets*
### SnipMate Parser *zh-luasnip-lsp-snippets-snipmate-parser*
### Transformations *zh-luasnip-lsp-snippets-transformations*
## Variables *zh-luasnip-variables*
### Environment Namespaces *zh-luasnip-variables-environment-namespaces*
### LSP-Snippets *zh-luasnip-variables-lsp-variables*
## Loaders *zh-luasnip-loaders*
### Snippet-specific filetype *zh-luasnip-loaders-snippet-specific-filetypes*
### VS-Code *zh-luasnip-loaders-vs-code*
### SNIPMATE *zh-luasnip-loaders-snipmate*
### Lua *zh-luasnip-loaders-lua*
### edit_snippets *zh-luasnip-loaders-edit_snippets*
## SnippetProxy *zh-luasnip-snippetproxy*
## ext_opts *zh-luasnip-ext_opts*
## Docstrings *zh-luasnip-docstrings*
## Docstring-Cache *zh-luasnip-docstring-cache*
## Events *zh-luasnip-events*
## Cleanup *zh-luasnip-cleanup*
## Logging *zh-luasnip-logging*
## Source *zh-luasnip-source*
## Selection *zh-luasnip-selection*
## Config-Options *zh-luasnip-config-options*
## Troubleshooting *zh-luasnip-troubleshooting*
### Adding Snippets *luasnip-troubleshooting-adding-snippets*
## API *luasnip-api*
vim:ft=markdown:norl:
